#summary Securely emulating clone() requires the creation of a new trusted thread and of a new page of memory that is securely shared with the trusted process.

==Steps to securely create a new thread==

 * sandbox'd thread talks to trusted process and requests a new thread to be created.
 
 * trusted process makes sure that only one clone request is being processed at any given time. In fact, the easiest thing is to suspend all other processing while clone() is being handled.
 
 * trusted process generates write protected code snippet in securely shared memory segment and tells trusted thread to execute it.
 
 * original trusted thread calls clone() to create new nascent thread. This thread is fully privileged and shares all resources with the caller (i.e. the previous trusted thread), and by extension it shares all resources with the sandbox'd threads.

 * nascent thread creates socketpair() for sending requests to trusted thread.
 
 * nascent thread creates another temporary thread that shares address space, but does not share filehandles.
 
 * nascent thread calls waitpid(). Loops on EINTR.
 
 * temporary thread tries to exclusively create file for file name that it has received in the write-protected snippet.
 
 * if open() fails, exit.
 
 * if open() succeeds, write known-safe contents to this file (e.g. a code snippet that exits the entire process). This ensures that we cannot trick the trusted thread into executing user-controlled code, if an attacker managed to confuse the trusted process about the location of the shared memory region.

 * call mmap() to create shared memory in a well-known location. This location must have guard pages on both sides. As there is only one such well-known location, the trusted process has to ensure that only one clone() request is pending at any given time.

 * call fork() to unshare the address space then exit the temporary thread.

 * the fork()'d process uses sendmsg() to send the file handle for the shared memory region to the trusted process. It also sends the file handle for talking to the trusted thread, and the new pid. The new pid is used as cookie by the trusted process to decide where to send responses, too. To simplify the code, this should probably happen on a dedicated socketpair().

 * the trusted process receives the file handle and maps the memory region as writable.
 
 * trusted thread returns from waitpid() and tries to mremap() shared memory from its original fixed location. It can do this by temporarily increasing the size of the mapping.
 
 * if mremap() fails, return an error to the sandbox'd thread which should retry the operation.

 * call clone() to create new trusted thread(). 

 * store file descriptor for trusted thread in thread local storage. This system call can potentially be corrupted by untrusted threads, but that's OK.

 * release privileges by entering seccomp mode.
 
 * return to caller.

 * after a new thread has been created, the trusted process sets a flag saying that the current list of restricted memory regions is incomplete. The next time, somebody requests to perform an operation that requires checking this list (e.g. mmap(MAP_FIXED) or munmap()), the trusted process will scan the /proc/`*`/maps for the sandbox'd process. By checking the device and inode numbers, it locates the address of the new securely shared memory. If the address has not yet been mremap()'d, the trusted process busy waits until it is.

 * we should also catch thread termination (by intercepting exit()). When a thread terminates, we have to release the shared memory in both the trusted thread and the trusted process. We must close() the socketpair(), and we must exit() the trusted thread.